"""Database of Axisymmetric Geometries and corresponding experimental/numerical results

Author:  Carlos E. Ribeiro Santa Cruz Mendoza, Nikolaus Romanow, A. Habermann

Geometries:     0 - Arbitrary Axisymmetric Geometry loaded with text file
                1 - 6:1 Ellipsoid (streamline as in [15]) ONLY FOR POTENTIAL FLOW VALIDATION
                2 - 8:1 Ellipsoid [3] for potential flow validation
                3 - Fuselage-like body of revolution [14] for potential flow validation
                4 - Airship Akron [13] use Ma = 0.15, alt = 2000, Xtr = 0.06
                5 - Modified 6:1 Spheroid for validation [16] use Ma = 0.0365, alt = 1000, Xtr = 0.05
                6 - F-57 Body for validation [17] use Ma = 0.045, alt = 500, Xtr = 0.475
                7 - ESDU Body 1 [18]
                8 - Waisted body of revolution [19] use Ma = 0.597, alt = 7680, Xtr = 0.05
                9 - Fuselage equivalent body (NASA 1969) use Ma = 0.75, alt = 10100 or 3000, Xtr = 0.05
                10 - Propulsive Fuselage generated by GenerateFuselage.py (axisymmetric or elliptic)
Sources:
    [3] Hess, J. L. & Smith, A. M.: Calculation of potential flow about arbitrary bodies.
        Progress in Aerospace Sciences 8 (1967), 1-138, ISSN 03760421
    [13] Patel, V. C.: a Simple Integral Method for the Calculation of Thick Axisymmetric
         Turbulent Boundary Layers. Aeronaut. Quart. 25 (1974).
    [14] Lewis, R. I.: Vortex Element Methods for Fluid Dynamic Analysis of Engineering Systems. 
         Cambridge Engine Technology Series, Cambridge University Press 1991
    [15] Nakayama, A.; Patel, V. C. & Landweber, L.: Flow interaction near the tail of a body of revolution: Part 1:
         Flow exterior to boundary layer and wake. Journal of Fluids Engineering, Transactions of the ASME 98 (1976)
    [16] Patel, V.; Nakayama, A. & Damian, R.: Measurements in the thick axisymmetric turbulent boundary layer
         near the tail of a body of revolution. Journal of Fluid Mechanics 63 (1974), 345-367
    [17] Patel, V. C.; Lee, Y. T. & Guven, O.: Measurements in the thick axisymmetric turbulent boundary layer
         and the near wake of a low-drag body of revolution. Turbulent Shear Flows I, Springer (1979).
    [18] ESDU: The influence of body geometry and flow conditions on axisymmetric velocity distribution
         at subcritical Mach numbers." ESDU International, London, UK, Data Item 78037 (1978) reports 77028g and 77020a.
    [19] Winter, K. G.; Rotta, J. & Smith, K.: Studies of the Turbulent Boundary Layer 
         on Waisted Body of Revolution in Subsonic and Supersonic Flow (1970)
    [20] Samuels, R. D.: Experimental Investigation of the Turbulent Boundary Layer on a Typical
         Subsonic Transport Fuselage. Tech. Rep. NASA Technical Note TN D-5242, NASA, Langley Station, Hampton, Va. 1969
"""

# Built-in/Generic Imports
import numpy as np
from scipy import interpolate

# Own modules
from geometry_generation.panel_geometry.generate_geometry_open_trailingedge import GenerateGeom
from geometry_generation.panel_geometry.parameter_sampling import paramSampling
from geometry_generation.finite_difference_geometry.generate_jet import jetSnel_AreaRule


def kuttaPanels(Xn_top, Yn_top, Xn_bot, Yn_bot, c):
    # add Kutta panel for lifting body
    c = 0.1 * (max(Xn_top) - min(Xn_top))  # Kutta panel is c times as long as nacelle panel at trailing edge
    # bisector of trailing edge angle
    alpha_top = np.arctan((Yn_top[-2] - Yn_top[-1]) / (Xn_top[-1] - Xn_top[-2]))
    alpha_bot = np.arctan((Yn_bot[-2] - Yn_bot[-1]) / (Xn_bot[-1] - Xn_bot[-2]))
    alpha = alpha_bot + (alpha_top - alpha_bot) / 2
    x_end = Xn_top[-1] + c
    y_end = Yn_bot[-1] - np.tan(alpha) * (x_end - Xn_bot[-1])
    Xn_kut = np.asarray([x_end, Xn_bot[-1], x_end])
    Yn_kut = np.asarray([y_end, Yn_bot[-1], y_end])
    Fm_kut = np.zeros(len(Xn_kut) - 1)

    return Xn_kut, Yn_kut, Fm_kut


def bodyGeometry(flags, geom, N, w, AR_ell, Xn_old, u_inf, nu, M_inf, plot, X_fuse=None, Y_fuse=None):
    # Initialization of experimental variables
    delta_exp = np.zeros((1, 2))
    delta_num = np.zeros((1, 2))
    delta_star_exp = np.zeros((1, 2))
    delta_star_num = np.zeros((1, 2))
    Theta_exp = np.zeros((1, 2))
    u_exp = np.zeros((1, 2))
    u_num = np.zeros((1, 2))
    H_exp = np.zeros((1, 2))
    H_num = np.zeros((1, 2))
    theta_exp = np.zeros((1, 2))
    re_exp = np.zeros((1, 2))
    Cp_exp = np.zeros((1, 2))
    Uprofexp = np.zeros((1, 2))
    Cf_exp = np.zeros((1, 2))

    # if flags[0] != 10 and flags[0] != 11:
    #     if plot == 0:
    #         N = N[0]
    #     Fm = 'dummy'

    if (flags[0] == 0):  # Upload of arbitrary geometry (discretized points on rows, X first column, Y second column)
        if plot == 0:
            # create arbitrary body from .txt file
            # for profiling only
            Xload = np.loadtxt('../../geometry_generation/validation_geometries/' + geom + '.txt')[:, 0]
            Yload = np.loadtxt('../../geometry_generation/validation_geometries/' + geom + '.txt')[:, 1]
            # Xload = np.loadtxt('../geometries/validation_geometries/' + geom + '.txt')[:, 0]
            # Yload = np.loadtxt('../geometries/validation_geometries/' + geom + '.txt')[:, 1]
            idx = np.where(Xload == 1111111111)
            n = len(idx[0]) - 1  # identify number of bodies
            if n < 1 and Xload != []:  # if only single body
                n = 1
            Fm = []
            Xn = []
            Yn = []
            X = []
            Y = []
            arc_length = []
            bodyflag = []

            if len(idx[0]) == 0:
                X.append(Xload)
                Y.append(Yload)
            else:
                for i in range(0, n):
                    X.append(Xload[idx[0][i] + 1:idx[0][i + 1]])
                    Y.append(Yload[idx[0][i] + 1:idx[0][i + 1]])

            for i in range(0, n):
                # streamline (axisymmetric) body
                if abs(Y[i][0]) < 0.01:
                    Fs = interpolate.UnivariateSpline(X[i], Y[i], s=0)
                    Xparam, arclength = paramSampling(X[i], Y[i], N[i], w, 0)
                    if flags[5] == 1:  # parametrised samples
                        if isinstance(Xn_old, int):
                            Xn.append(Xparam)
                        else:
                            Xn.append(Xn_old)
                    else:  # equidistant samples
                        Xfs = np.arange(0, X[i][-1] + (X[i][-1] - 0) / (N[i] - 1), (X[i][-1] - 0) / (N[i] - 1))
                        Xn.append(list(Xfs))
                    Yn.append(Fs(Xn[i]))
                    arc_length.append(arclength)
                    Fm.append(np.zeros(len(Xn[i]) - 1))
                    bodyflag.append('streamline')
                # lifting body, i.e. ring airfoil
                else:
                    # split coordinates of lifting body into coordinates of upper and lower half
                    idx2 = np.where(X[i] == X[i].min())
                    X_top = X[i][0:idx2[0][1]]
                    X_bot = X[i][idx2[0][1]:]
                    Y_top = Y[i][0:idx2[0][1]]
                    Y_bot = Y[i][idx2[0][1]:]
                    Fs_top = interpolate.UnivariateSpline(np.flip(X_top), np.flip(Y_top), s=0)
                    Xparam_top, arc_length_top = paramSampling(np.flip(X_top), np.flip(Y_top), N[i], w, 2)
                    Fs_bot = interpolate.UnivariateSpline(X_bot, Y_bot, s=0)
                    Xparam_bot, arc_length_bot = paramSampling(X_bot, Y_bot, N[i], w, 2)
                    if flags[5] == 1:  # parametrised samples
                        Xn_top = Xparam_top * 1
                        Xn_bot = Xparam_bot * 1
                    else:  # equidistant samples
                        Xfs_top = np.arange(0, X_top[-1] + (X_top[-1] - 0) / (N[i] - 1), (X_top[-1] - 0) / (N[i] - 1))
                        Xn_top = list(Xfs_top)
                        Xfs_bot = np.arange(0, X_bot[-1] + (X_bot[-1] - 0) / (N[i] - 1), (X_bot[-1] - 0) / (N[i] - 1))
                        Xn_bot = list(Xfs_bot)
                    Yn_top = Fs_top(Xn_top)
                    Yn_bot = Fs_bot(Xn_bot)
                    Fm_top = np.zeros(len(Xn_top) - 1)
                    Fm_bot = np.zeros(len(Xn_bot) - 1)
                    Xn.extend([np.flip(Xn_top), Xn_bot])
                    Yn.extend([np.flip(Yn_top), Yn_bot])
                    Fm.extend([Fm_top, Fm_bot])  # throughflow velocities
                    arc_length.extend([np.flip(arc_length_top), arc_length_bot])
                    i += 1
                    bodyflag.extend(['lifting', 'lifting'])
            if any(i == 'streamline' for i in bodyflag):
                idx3 = bodyflag.index('streamline')
                L = Xn[idx3][-1] - Xn[idx3][0]
            else:
                idx3 = bodyflag.index('lifting')
                L = Xn[idx3][0] - Xn[idx3][-1]

        else:
            X = np.loadtxt(geom + '.txt')[:, 0]
            Y = np.loadtxt(geom + '.txt')[:, 1]
            Xn = [X]
            Yn = [Y]
            arc_length = "dummy"
            Fm = "dummy"
            if abs(Y[0]) < 0.01:
                L = Xn[0][-1] - Xn[0][0]
            else:
                L = max(Xn[0]) - min(Xn[0])
        if flags[5] == 1:
            samples = '_param' + str(w)
        else:
            samples = '_equi'

        Re = u_inf * L / nu
        name = int(Re / (10 ** (int(np.log10(Re)))))
        file = geom + '_Tr' + str(flags[2]) + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(
            int(np.log10(Re))) + '_pg' \
               + str(flags[1]) + '_N' + str(N[0]) + '_it' + str(flags[3]) + '_compr' + str(flags[4]) + samples
    elif (flags[0] == 1):  # Geometry of 6:1 ellipsoid for validation against analytical results
        L = 1.578  # Length [m]
        X = np.linspace(0, 1, N[0])
        Yn = [((1 / 6) * (0.9655 * X - X ** 2) ** (1 / 2))]  # 6:1 ellipsoid
        for i in range(0, len(X)):
            if X[i] > 0.933:
                Yn[0][i] = 0.4333 * (1 - X[i])
        Xn = [np.linspace(0, 1, N[0])]
        Xn = [L * Xn[0]]  # Axial coordinate
        Yn = [L * Yn[0]]
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        Fm = [np.zeros(len(Xn[0]) - 1)]
        u_num = np.loadtxt("validation_data/g1Spheroid/SpheroidUeStream.txt", delimiter=',')
        file = 'g1'
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif (flags[0] == 2):  # Geometry of 8:1 ellipsoid for validation
        X = np.linspace(-1, 1, N[0])
        Yn = [(1 / 16) * (1 - ((X / 1) ** 2)) ** (1 / 2)]  # 8:1 ellipsoid
        Xn = [np.linspace(0, 1, N[0])]  # Axial coordinate
        file = 'g2'
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        L = Xn[0][-1]
        u_num = np.loadtxt("validation_data/g2Ellipsoid/8to1EllipsoidUe.txt", delimiter=',')
        Fm = [np.zeros(len(Xn[0]) - 1)]
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif (flags[0] == 3):  # Upload of Fuselage geometry for validation (Lewis 1991)
        X = np.loadtxt("../../geometry_generation/validation_geometries/bodyRev_Lewis1991.txt")[:, 0]
        Y = np.loadtxt("../../geometry_generation/validation_geometries/bodyRev_Lewis1991.txt")[:, 1]
        Xn = [list(X)]
        Yn = [list(Y)]
        file = 'g3'
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        L = Xn[0][-1]
        u_exp = np.loadtxt("../../studies/panel_studies/validation_data/g3Fuselage/LewisUe.txt", delimiter=',')
        u_exp[:, 0] = u_exp[:, 0] / L
        Fm = [np.zeros(len(Xn[0]) - 1)]
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif (flags[0] == 4):  # Upload of Airship Akron geometry for validation Ma = 0.15, alt = 2000, Xtr = 0.06
        X = np.loadtxt("../../geometry_generation/validation_geometries/bodyAkron.txt")[:, 0]
        Y = np.loadtxt("../../geometry_generation/validation_geometries/bodyAkron.txt")[:, 1]
        Ak = interpolate.UnivariateSpline(X, Y, s=0.0022)
        Xak = np.linspace(0, X[-1], N[0])
        Xn = [Xak]
        Yn = [Ak(Xn[0])]
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        L = Xn[0][-1]
        Re = u_inf * L / nu
        name = int(Re / (10 ** (int(np.log10(Re)))))
        file = 'g4' + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(int(np.log10(Re))) + '_pg' + str(
            flags[1]) + '_N' + str(N[0]) + '_it' + str(flags[3]) + '_compr' + str(flags[4])
        delta_exp = np.loadtxt("validation_data/g4Akron/Akrondelta.txt", delimiter=',')
        theta_exp = np.loadtxt("validation_data/g4Akron/AkronTheta.txt", delimiter=',')
        u_exp = np.loadtxt("validation_data/g4Akron/AkronUe.txt", delimiter=',')
        H_exp = np.loadtxt("validation_data/g4Akron/AkronH.txt", delimiter=',')
        Fm = [np.zeros(len(Xn[0]) - 1)]
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif (flags[0] == 5):  # Geometry of 6:1 spheroid for validation (Patel Nakayama 1976) Ma = 0.00365, alt = 1000
        L = 1.578  # Length [m]
        X = np.linspace(0, 1, N[0])
        Yn = [((1 / 6) * (0.9655 * X - X ** 2) ** (1 / 2))]  # 6:1 ellipsoid
        for i in range(0, len(X)):
            if X[i] > 0.933:
                Yn[0][i] = 0.4333 * (1 - X[i])
        Xn = [np.linspace(0, 1, N[0])]
        Xn = [L * Xn[0]]  # Axial coordinate
        Yn = [L * Yn[0]]
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        Re = u_inf * L / nu
        name = int(Re / (10 ** (int(np.log10(Re)))))
        file = 'g5' + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(int(np.log10(Re))) + '_pg' + str(
            flags[1]) + '_N' + str(N[0]) + '_it' + str(flags[3]) + '_compr' + str(flags[4])
        delta_exp = np.loadtxt("../../studies/panel_studies/validation_data/g5modSpheroid/Spheroiddelta.txt",
                               delimiter=',')
        theta_exp = np.loadtxt("../../studies/panel_studies/validation_data/g5modSpheroid/SpheroidTheta.txt",
                               delimiter=',')
        u_exp = np.loadtxt("../../studies/panel_studies/validation_data/g5modSpheroid/SpheroidUe.txt", delimiter=',')
        H_exp = np.loadtxt("../../studies/panel_studies/validation_data/g5modSpheroid/SpheroidH.txt", delimiter=',')
        if flags[3] == 1:
            Theta_exp = np.loadtxt(
                "../../studies/panel_studies/validation_data/g5modSpheroid/SpheroidThetaIteration.txt", delimiter=',')
            re_exp = np.loadtxt("../../studies/panel_studies/validation_data/g5modSpheroid/SpheroidreIteration.txt",
                                delimiter=',')
        Fm = [np.zeros(len(Xn[0]) - 1)]
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif (flags[0] == 6):  # Geometry of F-57 body for validation (Patel 1979)
        L = 1.219  # Length [m]
        r_m = L / 2 / 4.2735
        X_m = L * 0.4446
        Xn = [L * np.linspace(0, 1, N[0])]
        Yn = [np.zeros(len(Xn[0]))]
        xi = [(L - Xn[0]) / (L - X_m)]
        for i in range(0, len(Xn[0])):
            if Xn[0][i] < X_m:
                Yn[0][i] = r_m * (-1.1723 * ((Xn[0][i] / X_m) ** 4) + 0.7088 * ((Xn[0][i] / X_m) ** 3) + 1.0993 * (
                            (Xn[0][i] / X_m) ** 2) + 0.3642 * ((Xn[0][i] / X_m))) ** 0.5
            else:
                Yn[0][i] = r_m * (-0.11996 * (xi[0][i]) ** 5 - 2.58278 * (xi[0][i]) ** 4 + 3.52544 * (
                xi[0][i]) ** 3 + 0.17730 * (xi[0][i]) ** 2) ** 0.5
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        Re = u_inf * L / nu
        name = int(Re / (10 ** (int(np.log10(Re)))))
        file = 'g6' + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(int(np.log10(Re))) + '_pg' + str(
            flags[1]) + '_N' + str(N[0]) + '_it' + str(flags[3]) + '_compr' + str(flags[4])
        u_exp = np.loadtxt("validation_data/g6F57/f57Upot.txt", delimiter=',')
        Cp_exp = np.loadtxt("validation_data/g6F57/f57Cp.txt", delimiter=',')
        re_exp = np.loadtxt("validation_data/g6F57/f57re.txt", delimiter=',')
        Theta_exp = np.loadtxt("validation_data/g6F57/f57theta.txt", delimiter=',')
        H_exp = np.loadtxt("validation_data/g6F57/f57H.txt", delimiter=',')
        Fm = [np.zeros(len(Xn[0]) - 1)]
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif flags[0] == 7:
        L = float(input("Please insert the body's Length: "))  # Length [m]
        Re = u_inf * L / nu
        LD = float(input("Please insert the L/D ratio: "))
        l_f = L * 0.2
        # l_m = L*0.288
        l_a = L * 0.512
        R = (L / LD) / 2
        Xn = [L * np.linspace(0, 1, N[0])]
        Yn = [np.zeros(len(Xn[0]))]
        for i in range(0, len(Xn[0])):
            if Xn[0][i] < l_f:
                Yn[0][i] = R * ((1 / np.pi) * (np.arccos(1 - 2 * (Xn[0][i] / l_f)) - 2 * (1 - 2 * (Xn[0][i] / l_f)) * (
                            (Xn[0][i] / l_f - (Xn[0][i] / l_f) ** 2) ** 0.5))) ** 0.5
            elif Xn[0][i] >= (L - l_a):
                Yn[0][i] = R * ((1 / np.pi) * (
                            np.arccos(1 - 2 * ((L - Xn[0][i]) / l_a)) - 2 * (1 - 2 * ((L - Xn[0][i]) / l_a)) * (
                                ((L - Xn[0][i]) / l_a - ((L - Xn[0][i]) / l_a) ** 2) ** 0.5))) ** 0.5
            else:
                Yn[0][i] = R
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        file = 'g7' + '_L' + str(int(L)) + '_Tr' + str(flags[2]) + '_LD' + str(int(LD)) + '_Re' + str(
            int(np.log10(Re))) + '_M' + str(M_inf) + '_comp' + str(flags[1]) + '_N' + str(N[0]) + '_it' + str(flags[3])
        if np.isclose(LD, 5, rtol=1e-1) and np.isclose(flags[2], 0.01, atol=0.05) and np.isclose(np.log10(Re), 7,
                                                                                                 rtol=5e-2):  # and flags[1] == 1 :
            delta_num = np.loadtxt("validation_data/ESDU/body01Tr00LD05Re7M08_delta.txt", delimiter=',')
            delta_star_num = np.loadtxt("validation_data/ESDU/body01Tr00LD05Re7M08_disp.txt", delimiter=',')
            H_num = np.loadtxt("validation_data/ESDU/body01Tr00LD05Re7M08_H.txt", delimiter=',')
        if np.isclose(LD, 5, rtol=1e-1) and np.isclose(flags[2], 0.15, atol=0.05) and np.isclose(np.log10(Re), 7,
                                                                                                 rtol=5e-2) and flags[
            1] == 0:
            delta_num = np.loadtxt("validation_data/ESDU/body01Tr15LD05Re7M00_delta.txt", delimiter=',')
            delta_star_num = np.loadtxt("validation_data/ESDU/body01Tr15LD05Re7M00_disp.txt", delimiter=',')
            H_num = np.loadtxt("validation_data/ESDU/body01Tr15LD05Re7M00_H.txt", delimiter=',')
        if np.isclose(LD, 10, rtol=1e-1) and np.isclose(flags[2], 0.01, atol=0.05) and np.isclose(np.log10(Re), 7,
                                                                                                  rtol=5e-2):  # and flags[1] == 1:
            delta_num = np.loadtxt("validation_data/ESDU/body01Tr00LD10Re7M07_delta.txt", delimiter=',')
            delta_star_num = np.loadtxt("validation_data/ESDU/body01Tr00LD10Re7M07_disp.txt", delimiter=',')
            H_num = np.loadtxt("validation_data/ESDU/body01Tr00LD10Re7M07_H.txt", delimiter=',')
        if np.isclose(LD, 5, rtol=1e-1) and np.isclose(flags[2], 0.01, atol=0.05) and np.isclose(np.log10(Re), 9,
                                                                                                 rtol=5e-2) and flags[
            1] == 0:
            delta_num = np.loadtxt("validation_data/ESDU/body01Tr00LD05Re9M00_delta.txt", delimiter=',')
            delta_star_num = np.loadtxt("validation_data/ESDU/body01Tr00LD05Re9M00_disp.txt", delimiter=',')
            H_num = np.loadtxt("validation_data/ESDU/body01Tr00LD05Re9M00_H.txt", delimiter=',')
        Fm = [np.zeros(len(Xn[0]) - 1)]
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif (flags[0] == 8):  # Geometry of Winter et. al 1970
        L = 1.524  # Length [m]
        Re = u_inf * L / nu
        Xn = [L * np.linspace(0, 1, N[0])]
        Yn = [np.zeros(len(Xn[0]))]
        for i in range(0, len(Xn[0])):
            if Xn[0][i] / L <= 0.14158:
                Yn[0][i] = L * (0.36397 * (Xn[0][i] / L))
            elif 0.14158 < Xn[0][i] / L <= 0.45725:
                Yn[0][i] = L * (6.34730 * (Xn[0][i] / L) ** 4 - 6.49221 * (Xn[0][i] / L) ** 3 + 1.22668 * (
                            Xn[0][i] / L) ** 2 + 0.33498 * (Xn[0][i] / L) - 0.00461)
            elif 0.45725 < Xn[0][i] / L <= 0.64473:
                Yn[0][i] = L * (-0.236382 * (Xn[0][i] / L) ** 3 + 0.607620 * (Xn[0][i] / L) ** 2 - 0.595521 * (
                            Xn[0][i] / L) + 0.229694)
            elif 0.64473 < Xn[0][i] / L <= 0.76317:
                Yn[0][i] = L * (-53.58258 * (Xn[0][i] / L) ** 4 + 150.87806 * (Xn[0][i] / L) ** 3 - 158.03866 * (
                            Xn[0][i] / L) ** 2 + 72.96859 * (Xn[0][i] / L) - 12.4939)
            else:
                Yn[0][i] = L * (0.236382 * (Xn[0][i] / L) ** 3 - 0.390789 * (Xn[0][i] / L) ** 2 + 0.290242 * (
                            Xn[0][i] / L) - 0.064001)
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        name = int(Re / (10 ** (int(np.log10(Re)))))
        file = 'g8' + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(int(np.log10(Re))) + '_pg' + str(
            flags[1]) + '_N' + str(N[0]) + '_it' + str(flags[3]) + '_compr' + str(flags[4])
        if np.isclose(M_inf, 0.6, rtol=1e-1) and np.isclose(np.log10(Re), 7, rtol=5e-2):
            Cp_exp = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedCp_Ma06.txt",
                                delimiter=',')
            Cp_exp[:, 1] = -1 * Cp_exp[:, 1]
            delta_exp = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waisteddelta_Ma06.txt",
                                   delimiter=',')
            delta_star_exp = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waisteddisp_Ma06.txt",
                                        delimiter=',')
            theta_exp = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waisteddelta2_Ma06.txt",
                                   delimiter=',')
            H_exp = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedH_Ma06.txt", delimiter=',')
            Uprofexp_0 = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedUprof_0.4_Ma06.txt",
                                    delimiter='\t')
            Uprofexp_1 = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedUprof_0.475_Ma06.txt",
                                    delimiter='\t')
            Uprofexp_2 = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedUprof_0.55_Ma06.txt",
                                    delimiter='\t')
            Uprofexp_3 = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedUprof_0.7_Ma06.txt",
                                    delimiter='\t')
            Uprofexp_4 = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedUprof_0.83_Ma06.txt",
                                    delimiter='\t')
            Uprofexp_5 = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedUprof_0.98_Ma06.txt",
                                    delimiter='\t')
            Uprofexp = [Uprofexp_0, Uprofexp_1, Uprofexp_2, Uprofexp_3, Uprofexp_4, Uprofexp_5]
            Cf_exp = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedCf_Ma06.txt",
                                delimiter=',')
        if np.isclose(M_inf, 0.8, rtol=1e-1) and np.isclose(np.log10(Re), 7, rtol=5e-2):
            Cp_exp = np.loadtxt("../../studies/panel_studies/validation_data/g8waisted/waistedCp_Ma08.txt",
                                delimiter=',')
            Cp_exp[:, 1] = -1 * Cp_exp[:, 1]
        Fm = [np.zeros(len(Xn[0]) - 1)]
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif (flags[0] == 9):  # Upload of equivalent fuselage from NASA 1969
        X = np.loadtxt("../../geometry_generation/validation_geometries/fuselageNASA.txt")[:, 0]
        Y = np.loadtxt("../../geometry_generation/validation_geometries/fuselageNASA.txt")[:, 1]
        Ak = interpolate.UnivariateSpline(X, Y, s=0.000005)
        Xak = np.linspace(0, X[-1], N[0])
        Xn = [Xak]
        Yn = [Ak(Xn[0])]
        # Parametrised discretization
        Xparam, arc_length = paramSampling(Xn[0], Yn[0], N[0], w, 0)
        if flags[5] == 1:
            Fs = interpolate.UnivariateSpline(Xn[0], Yn[0], s=0)
            Xn[0] = Xparam
            Yn[0] = Fs(Xn[0])
        L = Xn[0][-1]
        Re = u_inf * L / nu
        name = int(Re / (10 ** (int(np.log10(Re)))))
        file = 'g9' + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(int(np.log10(Re))) + '_pg' + str(
            flags[1]) + '_N' + str(N[0]) + '_it' + str(flags[3]) + '_compr' + str(flags[4])
        if np.isclose(np.log10(Re), 7, rtol=1e-2):
            Cp_exp = np.loadtxt("../../studies/panel_studies/validation_data/g9fuselageNASA/fuselageCp_all.txt",
                                delimiter=',')
            theta_exp = np.loadtxt("../../studies/panel_studies/validation_data/g9fuselageNASA/fuselageTheta_all.txt",
                                   delimiter=',')
            theta_exp[:, 1] = L * theta_exp[:, 1] * 1e-4
            delta_exp = np.loadtxt("../../studies/panel_studies/validation_data/g9fuselageNASA/fuselagedelta_all.txt",
                                   delimiter=',')
            delta_exp[:, 1] = L * delta_exp[:, 1] * 1e-3
            delta_star_exp = np.loadtxt(
                "../../studies/panel_studies/validation_data/g9fuselageNASA/fuselageDisp_all.txt", delimiter=',')
            delta_star_exp[:, 1] = L * delta_star_exp[:, 1] * 1e-4
            H_exp = np.loadtxt("../../studies/panel_studies/validation_data/g9fuselageNASA/fuselageH_all.txt",
                               delimiter=',')
        if np.isclose(np.log10(Re), 7.3, rtol=1e-2):
            Cp_exp = np.loadtxt("../../studies/panel_studies/validation_data/g9fuselageNASA/fuselageCp_90.txt",
                                delimiter=',')
            theta_exp = np.loadtxt(
                "../../studies/panel_studies/validation_data/g9fuselageNASA/fuselageTheta_90_Re2e7.txt", delimiter=',')
            theta_exp[:, 1] = L * theta_exp[:, 1] * 1e-4
            delta_exp = np.loadtxt(
                "../../studies/panel_studies/validation_data/g9fuselageNASA/fuselagedelta_90_Re2e7.txt", delimiter=',')
            delta_exp[:, 1] = L * delta_exp[:, 1] * 1e-3
            delta_star_exp = np.loadtxt(
                "../../studies/panel_studies/validation_data/g9fuselageNASA/fuselageDisp_90_Re2e7.txt", delimiter=',')
            delta_star_exp[:, 1] = L * delta_star_exp[:, 1] * 1e-4
            H_exp = np.loadtxt("../../studies/panel_studies/validation_data/g9fuselageNASA/fuselageH_90_Re2e7.txt",
                               delimiter=',')
        Fm = [np.zeros(len(Xn[0]) - 1)]
        N[0] = len(Xn[0])
        arc_length = [arc_length]
    elif (flags[0] == 10):  # PFC from GenerateGeom (axisymmetric or elliptic)
        if plot == 0:  # in 'calculateBoundaryLayer.py'
            Geom = GenerateGeom(67.2, 0.93, 11.03, 0.51, 0.57, 0.69, 0.7, 'baseline', AR_ell).build_geometry()

            if N[0] > 0:  # fuselage
                full_list_fuselage = np.asarray(Geom[0])
                X_f = full_list_fuselage[:, 0]
                Y_f = full_list_fuselage[:, 1]

                Fs_f = interpolate.UnivariateSpline(X_f, Y_f, s=0)
                Xparam, arc_fus = paramSampling(X_f, Y_f, N[0], w, 0)

                if flags[5] == 1:  # parametrised samples
                    if isinstance(Xn_old, int):
                        Xn_fus = Xparam * 1
                    else:
                        Xn_fus = Xn_old
                else:  # equidistant samples
                    Xfs = np.linspace(0, X_f[-1], N[0])
                    Xn_fus = list(Xfs)
                Yn_fus = Fs_f(Xn_fus)
                Fm_fus = np.zeros(len(Xn_fus) - 1)
            else:
                Xn_fus = []
                Yn_fus = []
                Fm_fus = []
                arc_fus = []

            if N[1] > 0:  # nacelle
                full_list_nacelle_top = np.asarray(Geom[1])
                full_list_nacelle_bottom = np.asarray(Geom[2])

                X = full_list_nacelle_bottom[:, 0]  # nacelle bottom
                Y = full_list_nacelle_bottom[:, 1]
                Fs = interpolate.UnivariateSpline(X, Y, s=0)
                Xn_bot, arc_bot = paramSampling(X, Y, int(N[1] / 2), w, 1)
                Yn_bot = Fs(Xn_bot)
                Fm_bot = np.zeros(len(Xn_bot) - 1)

                Xn_bot_1 = Xn_bot * 1  # dummy variable to determine discretization of rotor and stator
                Yn_bot_1 = Yn_bot * 1  # dummy variable to determine discretization of rotor and stator

                X = np.flip(full_list_nacelle_top[:, 0])  # nacelle top
                Y = np.flip(full_list_nacelle_top[:, 1])
                Fs = interpolate.UnivariateSpline(X, Y, s=0)
                Xn_top, arc_top = paramSampling(X, Y, int(N[1] / 2), w, 2)
                Yn_top = Fs(Xn_top)
                Fm_top = np.zeros(len(Xn_top) - 1)
            else:
                full_list_nacelle_bottom = np.asarray(Geom[2])
                X = full_list_nacelle_bottom[:, 0]
                Y = full_list_nacelle_bottom[:, 1]

                Xn_bot_1 = np.flip(X) * 1  # dummy variable to determine discretization of rotor and stator
                Yn_bot_1 = np.flip(Y) * 1  # dummy variable to determine discretization of rotor and stator

                Xn_bot = []
                Yn_bot = []
                Fm_bot = []
                arc_bot = []
                Xn_top = []
                Yn_top = []
                Fm_top = []
                arc_top = []

            if N[3] > 0:  # rotor
                xy_rot = Geom[3]
                x_rot = xy_rot[0]
                idx_r = np.where(Xn_fus > x_rot)[0][0]  # index right of rotor on fuselage
                x_ip = [Xn_fus[idx_r - 1], Xn_fus[idx_r]]
                y_ip = [Yn_fus[idx_r - 1], Yn_fus[idx_r]]
                y_rot1 = np.interp(x_rot, x_ip, y_ip)
                idx_l = np.where(Xn_bot_1 < x_rot)[0][0]  # index left of rotor on nacelle bottom
                x_ip = [Xn_bot_1[idx_l], Xn_bot_1[idx_l - 1]]
                y_ip = [Yn_bot_1[idx_l], Yn_bot_1[idx_l - 1]]
                y_rot2 = np.interp(x_rot, x_ip, y_ip)
                Xn_rot = x_rot * np.ones(N[3])
                Yn_rot = np.linspace(y_rot1, y_rot2, N[3])
                Fm_rot = []  # no rotor throughflow velocity specified for first potential flow computation
            else:
                Xn_rot = []
                Yn_rot = []
                Fm_rot = []

            if N[4] > 0:  # stator
                xy_stat = Geom[4]
                x_stat = xy_stat[0]
                idx_r = np.where(Xn_fus > x_stat)[0][0]  # index right of stator on fuselage
                x_ip = [Xn_fus[idx_r - 1], Xn_fus[idx_r]]
                y_ip = [Yn_fus[idx_r - 1], Yn_fus[idx_r]]
                y_stat1 = np.interp(x_stat, x_ip, y_ip)
                idx_l = np.where(Xn_bot_1 < x_stat)[0][0]  # index left of stator on nacelle bottom
                x_ip = [Xn_bot_1[idx_l], Xn_bot_1[idx_l - 1]]
                y_ip = [Yn_bot_1[idx_l], Yn_bot_1[idx_l - 1]]
                y_stat2 = np.interp(x_stat, x_ip, y_ip)
                Xn_stat = x_stat * np.ones(N[4])
                Yn_stat = np.linspace(y_stat1, y_stat2, N[4])
                Fm_stat = []  # no stator throughflow velocity specified for first potential flow computation
            else:
                Xn_stat = []
                Yn_stat = []
                Fm_stat = []

            if N[5] > 0 and N[1] > 0:  # Kutta panel
                # add Kutta panels for closure
                Xn_kut, Yn_kut, Fm_kut = kuttaPanels(Xn_top, Yn_top, Xn_bot, Yn_bot, 2)
            else:
                Xn_kut = []
                Yn_kut = []
                Fm_kut = []

            if N[2] > 0 and N[1] > 0:  # jet
                if N[5] > 0:
                    x_start = Xn_kut[-1]
                    y_start = Yn_kut[-1]
                else:
                    x_start = Xn_top[-1]
                    y_start = Yn_top[-1]
                if N[0] > 0:
                    d_eq = 2 * np.sqrt(y_start ** 2 - Fs_f(x_start) ** 2)  # Fuselage required
                else:
                    d_eq = 2 * y_start
                s_jet = np.zeros(N[2])
                Xn_jet = np.zeros(N[2])
                r_i = np.zeros(N[2])
                for i in range(0, N[2]):
                    # if s_jet[i]/d <= 30:
                    # s_jet[i] = s_jet[i-1] + (0.1 * d) * 1.3**(i-1)
                    if i >= 1:
                        s_jet[i] = s_jet[i - 1] + (0.1 * d_eq) * 1.3 ** (i - 1)
                    Xn_jet[i] = x_start + s_jet[i]
                    if N[0] > 0:
                        if Xn_jet[i] <= X_f[-1]:  # Fuselage required
                            r_i[i] = Fs_f(Xn_jet[
                                              i])  # Fuselage required
                # Yn_jet, Vz_jet = jetLiem_AreaRule(s_jet, d_eq, r_i)            # Liem jet model
                # Yn_jet, Vz_jet = jetSeibold_AreaRule(s_jet, d_eq, r_i)         # Seibold jet model
                Yn_jet, Vz_jet = jetSnel_AreaRule(s_jet, d_eq, r_i)  # Snel jet model (*default)
                Xm_jet = np.zeros(len(Xn_jet) - 1)  # Panel control point X-coordinate
                for i in range(len(Xn_jet) - 1):
                    Xm_jet[i] = 0.5 * (Xn_jet[i] + Xn_jet[i + 1])
                Fs_Vz = interpolate.UnivariateSpline(Xn_jet, Vz_jet, s=0)
                Fm_jet = np.zeros(len(Xm_jet))  # without jet entrainment
                # Fm_jet = Fs_Vz(Xm_jet) * u_nozzle # with jet entrainment (u_nozzle not included yet)

            else:
                Xn_jet = []
                Yn_jet = []
                Fm_jet = []

            Xn = [Xn_fus, Xn_bot, Xn_top, Xn_jet, Xn_rot, Xn_stat, Xn_kut]
            Yn = [Yn_fus, Yn_bot, Yn_top, Yn_jet, Yn_rot, Yn_stat, Yn_kut]
            Fm = [Fm_fus, Fm_bot, Fm_top, Fm_jet, Fm_rot, Fm_stat, Fm_kut]  # throughflow velocities
            arc_length = [arc_fus, arc_bot, arc_top, [], [], [], []]

        else:  # in 'plot_boundary_layer.py'
            Xn = np.loadtxt(geom + '.txt')[:, 0]
            Yn = np.loadtxt(geom + '.txt')[:, 1]
            Fm = 'dummy'
            arc_length = "dummy"

        if flags[5] == 1:
            samples = '_param' + str(w)
        else:
            samples = '_equi'

        if plot == 0:
            L = Xn_fus[-1]
        else:
            if flags[0] == 10:
                L = Xn[N[0] - 1]
            else:
                L = Xn[-1]
        Re = u_inf * L / nu
        name = int(Re / (10 ** (int(np.log10(Re)))))
        shape = 'Ell' + str(AR_ell)
        file = 'PropFus' + shape + '_Tr' + str(flags[2]) + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(
            int(np.log10(Re))) \
               + '_pg' + str(flags[1]) + '_N' + str(N[0]) + '_' + str(N[1]) + '_' + str(N[2]) + '_' + str(N[3]) + '_it' \
               + str(flags[3]) + '_compr' + str(flags[4]) + samples
    elif (flags[0] == 11):  # PFC from GenerateGeom (axisymmetric or elliptic)
        if plot == 0:  # in 'calculateBoundaryLayer.py'
            Geom = GenerateGeom(67.2, 0.93, 11.03, 0.51, 0.57, 0.69, 0.7, 'baseline', AR_ell).build_geometry()

            if N[0] > 0:  # fuselage
                full_list_fuselage = np.asarray(Geom[0])
                X_f = full_list_fuselage[:, 0]
                Y_f = full_list_fuselage[:, 1]

                Fs_f = interpolate.UnivariateSpline(X_f, Y_f, s=0)
                Xparam, arc_fus = paramSampling(X_f, Y_f, N[0], w, 0)

                if flags[5] == 1:  # parametrised samples
                    if isinstance(Xn_old, int):
                        Xn_fus = Xparam * 1
                    else:
                        Xn_fus = Xn_old
                else:  # equidistant samples
                    Xfs = np.linspace(0, X_f[-1], N[0])
                    Xn_fus = list(Xfs)
                Yn_fus = Fs_f(Xn_fus)
                Fm_fus = np.zeros(len(Xn_fus) - 1)
            else:
                Xn_fus = []
                Yn_fus = []
                Fm_fus = []
                arc_fus = []

            if N[1] > 0:  # nacelle
                full_list_nacelle_top = np.asarray(Geom[1])
                full_list_nacelle_bottom = np.asarray(Geom[2])

                X_top = full_list_nacelle_top[:, 0]
                X_bot = full_list_nacelle_bottom[:, 0]
                Y_top = full_list_nacelle_top[:, 1]
                Y_bot = full_list_nacelle_bottom[:, 1]
                Fs_top = interpolate.UnivariateSpline(np.flip(X_top), np.flip(Y_top), s=0)
                Xparam_top, arc_length_top = paramSampling(np.flip(X_top), np.flip(Y_top), N[1], w, 2)
                Fs_bot = interpolate.UnivariateSpline(X_bot, Y_bot, s=0)
                Xparam_bot, arc_length_bot = paramSampling(X_bot, Y_bot, N[2], w, 2)
                if flags[5] == 1:  # parametrised samples
                    Xn_top = Xparam_top * 1
                    Xn_bot = Xparam_bot * 1
                else:  # equidistant samples
                    Xfs_top = np.linspace(0, X_top[-1], N[1])
                    Xn_top = list(Xfs_top)
                    Xfs_bot = np.linspace(0, X_bot[-1], N[2])
                    Xn_bot = list(Xfs_bot)
                Yn_top = Fs_top(Xn_top)
                Yn_bot = Fs_bot(Xn_bot)
                Fm_top = np.zeros(len(Xn_top) - 1)
                Fm_bot = np.zeros(len(Xn_bot) - 1)

            Xn = [Xn_fus, np.flip(Xn_top), Xn_bot]
            Yn = [Yn_fus, np.flip(Yn_top), Yn_bot]
            Fm = [Fm_fus, Fm_top, Fm_bot]  # throughflow velocities
            arc_length = [arc_fus, arc_length_top, arc_length_bot]

        else:  # in 'plot_boundary_layer.py'
            Xn = np.loadtxt(geom + '.txt')[:, 0]
            Yn = np.loadtxt(geom + '.txt')[:, 1]
            Fm = 'dummy'
            arc_length = "dummy"

        if flags[5] == 1:
            samples = '_param' + str(w)
        else:
            samples = '_equi'

        if plot == 0:
            L = Xn_fus[-1]
        else:
            if flags[0] == 10:
                L = Xn[N[0] - 1]
            else:
                L = Xn[-1]
        Re = u_inf * L / nu
        name = int(Re / (10 ** (int(np.log10(Re)))))
        shape = 'Ell' + str(AR_ell)
        file = 'PropFus' + shape + '_Tr' + str(flags[2]) + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(
            int(np.log10(Re))) \
               + '_pg' + str(flags[1]) + '_N' + str(N[0]) + '_' + str(N[1]) + '_' + str(N[2]) + '_' + str(0) + '_it' \
               + str(flags[3]) + '_compr' + str(flags[4]) + samples

    elif flags[0] == 15:
        if N[0] > 0:  # fuselage
            X_f = X_fuse
            Y_f = Y_fuse
            L = max(X_fuse) - min(X_fuse)
            Fs_f = interpolate.UnivariateSpline(X_f, Y_f, s=0)
            Xparam, arc_fus = paramSampling(X_f, Y_f, N[0], w, 0)

            if flags[5] == 1:  # parametrised samples
                if isinstance(Xn_old, int):
                    Xn_fus = Xparam * 1
                else:
                    Xn_fus = Xn_old
            else:  # equidistant samples
                Xfs = np.linspace(0, X_f[-1], N[0])
                Xn_fus = list(Xfs)
            Yn_fus = Fs_f(Xn_fus)
            Fm_fus = np.zeros(len(Xn_fus) - 1)

            Xn = [Xn_fus]
            Yn = [Yn_fus]
            Fm = [Fm_fus]
            arc_length = [arc_fus]
        else:
            Xn = []
            Yn = []
            Fm = []
            arc_length = []

        if flags[5] == 1:
            samples = '_param' + str(w)
        else:
            samples = '_equi'

        Re = u_inf * L / nu
        name = int(Re / (10 ** (int(np.log10(Re)))))

        file = 'PFC' + '_Tr' + str(flags[2]) + '_M' + str(M_inf) + '_Re' + str(name) + 'e' + str(int(np.log10(Re))) \
               + '_pg' + str(flags[1]) + '_N' + str(N[0]) + '_' + str(0) + '_it' \
               + str(flags[3]) + '_compr' + str(flags[4]) + samples

    return Xn, Yn, Fm, N, L, arc_length, file, delta_exp, delta_star_exp, Theta_exp, u_exp, H_exp, theta_exp, re_exp, \
           Cp_exp, u_num, delta_star_num, delta_num, H_num, Uprofexp, Cf_exp
